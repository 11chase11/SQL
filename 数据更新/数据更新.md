# 第四章 数据更新
## 4.1
## 4.2
## 4.3 数据的更新（UPDATE语句的使用方法）
### UPDATE语句的基本用法
通过执行UPDATE语句，可以改变表中某列的数据，更新对象的列和更新后的值都记述在 SET 子句中。基础代码如下：
```
UPDATE <表名>
 SET <列名> = <表达式>;
```
例如 将登记日期全部更新为“2009-10-10”
```
UPDATE Product
 SET regist_date = '2009-10-10';
```
结果如下  
![image](https://user-images.githubusercontent.com/61198794/115409637-82170080-a224-11eb-80bd-879d7d8bd2b1.png)  
注意：UPDATE会将原本为NULL也更新掉
### 指定条件的UPDATE语句（搜索型UPDATE）
可以搭配DELETE和WHERE更新指定行的指定列。基础代码如下：
```
UPDATE <表名>
 SET <列名> = <表达式>
WHERE <条件>;
```
例如 将商品种类为厨房用具的记录的销售单价更新为原来的10倍
```
UPDATE Product
SET sale_price = sale_price * 10
WHERE product_type = '厨房用具';
```
结果如下  
![image](https://user-images.githubusercontent.com/61198794/115410074-e9cd4b80-a224-11eb-9ad5-e848b84cdf8f.png)  
### 使用NULL更新
使用 UPDATE 也可以将列更新为NULL（该更新俗称为NULL清空）。此时只需要将赋值表达式右边的值直接写为NULL即可
例如 将商品种类为厨房用具的记录的销售单价更新为原来的10倍
```
UPDATE Product
 SET regist_date = NULL
 WHERE product_id = '0008';
```
结果如下  
![image](https://user-images.githubusercontent.com/61198794/115410293-1719f980-a225-11eb-8c2d-d6042ca9b485.png)  
注意：只有未设置NOT NULL约束和主键约束的列才可以清空为NULL。如果将设置了上述约束的列更新为 NULL，就会出错。
### 多列更新
UPDATE 语句的 SET 子句支持同时将多个列作为更新对象。
例如 以下的两步操作可以合并为一步：
```
-- 一条UPDATE语句只更新一列
UPDATE Product
 SET sale_price = sale_price * 10
 WHERE product_type = '厨房用具';
UPDATE Product
 SET purchase_price = purchase_price / 2
 WHERE product_type = '厨房用具';
```
有两种合并方法：
```
-- 使用逗号对列进行分隔排列
UPDATE Product
 SET sale_price = sale_price * 10,
 purchase_price = purchase_price / 2
 WHERE product_type = '厨房用具';
```
```
-- 将列用()括起来的清单形式
UPDATE Product
 SET (sale_price, purchase_price) = (sale_price * 10, 
purchase_price / 2)
 WHERE product_type = '厨房用具';
```
## 4.4 事务
事务就是需要在同一个处理单元中执行的一系列更新处理的即合。通过添加事务开始语句和事务结束语句，我们想进行的多个数据操作会在事务结束语句后统一进行。基础代码如下：
```
事务开始语句;
 DML语句①;
 DML语句②;
 DML语句③;
 . . .
事务结束语句（COMMIT或者ROLLBACK）;
```
注意：实际上，在标准 SQL 中并没有定义事务的开始语句，而是由各个 DBMS 自己来定义的。比较有
代表性的语法如下：  
● SQL Server、PostgreSQL  
BEGIN TRANSACTION  
● MySQL  
START TRANSACTION  
● Oracle、DB2  
无  
### COMMIT 提交处理
COMMIT 是提交事务包含的全部更新处理的结束指令（流程如下图），相当于文件处理中的覆盖保存。一旦提交，就无法恢复到事务开始前的状态了。因此，在提交之前一定要确认是否真的需要进行这些更新。  
![image](https://user-images.githubusercontent.com/61198794/115411724-4da44400-a226-11eb-8ee3-9255ea7ba983.png)  
### ROLLBACK 取消处理
ROLLBACK 是取消事务包含的全部更新处理的结束指令（流程如下图），相当于文件处理中的放弃保存。一旦回滚，数据库就会恢复到事务开始之前的状态。通常回滚并不会像提交那样造成大规模的数据损失。  
![image](https://user-images.githubusercontent.com/61198794/115411921-79bfc500-a226-11eb-8704-57d9b7399ccb.png)  
注：实际上，几乎所有的数据库产品的事务都无需开始指令。这是因为大部分情况下，事务在数据库连接建立时就已经悄悄开始了，并不需要用户再明确发出开始指令。例如，使用 Oracle 时，数据库连接建立之后，第一条 SQL 语句执行的同时，事务就已经悄悄开始了。
### ACID 特性
DBMS 的事务都遵循四种特性，将这四种特性的首字母结合起来统称为 ACID 特性。这是所有 DBMS 都必须遵守的规则。   
● 原子性（Atomicity）  
原子性是指在事务结束时，其中所包含的更新处理要么全部执行，要么完全不执行，也就是要么占有一切要么一无所有。  
● 一致性（Consistency）  
一致性指的是事务中包含的处理要满足数据库提前设置的约束，如主键约束或者 NOT NULL 约束等。  
![image](https://user-images.githubusercontent.com/61198794/115412420-dd49f280-a226-11eb-8eb7-6cd406283015.png)  
● 隔离性（Isolation）  
隔离性指的是保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。  
● 持久性（Durability）  
持久性也可以称为耐久性，指的是在事务（不论是提交还是回滚）结束后，DBMS 能够保证该时间点的数据状态会被保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某种手段进行恢复。

