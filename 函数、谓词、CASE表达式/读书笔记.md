## 6.2 谓词
-什么是谓词？
-谓词本身是上一节函数中的一种，是需要满足特定条件的函数，该条件就是“返回值是真值”。谓词和函数最大的区别则是，函数的返回值可以是数字、字符串或日期等，而谓词的返回值全都是真值（TRUE/FALSE/UNKOWN)。

本节我们将介绍以下几种谓词：
LIKE
BETWEEN
IS NULL/IS NOT NULL
IN
EXISTS

### 6.2.1 LIKE谓词--字符串的部分一致查询

在以前的章节，使用字符串作为查询条件时，我们都是使用的"=", 等号条件只有当字符串完全一致时才为真。而LIKE谓词则放松了这一条件，即当字符串的部分一致时也可以进行查询。

部分一致大致分为：(1)前方一致；(2)中间一致；(3)后方一致三种类型。

首先创建一个SampleLike表，代码如下：
```
-- DDL 创建表格：

  CREATE TABLE SampleLike
  ( strcol VARCHAR(6) NOT NULL,
  PRIMARY KEY (strcol));
  
-- DML 插入数据：

  BEGIN TRANSACTION;
  INSERT INTO SampleLike (strcol) VALUES ('abcddd');
  INSERT INTO SampleLike (strcol) VALUES ('dddabc');
  INSERT INTO SampleLike (strcol) VALUES ('abdddc');
  INSERT INTO SampleLike (strcol) VALUES ('abcdd');
  INSERT INTO SampleLike (strcol) VALUES ('ddabc');
  INSERT INTO SampleLike (strcol) VALUES ('abddc');
  COMMIT;
```
得到如下表格：

![image](https://user-images.githubusercontent.com/59467331/118671727-4cb50100-b82a-11eb-8472-d83f416bea3b.png)

**(1)前方一致: 选取出“ddd**abc”
  
  所谓前方一致，就是选取出作为查询条件的字符串（这里是“ddd”）与查询对象字符串**起始部分相同**的记录的查询方法。
  
  代码如下：
 ```
  SELECT *
    FROM SampleLike
   WHERE strcol LIKE 'ddd%';
 ```
  结果如下：
  
 ![image](https://user-images.githubusercontent.com/59467331/118672371-c4832b80-b82a-11eb-8b32-4459d5553f0f.png)

  其中的%是代表“0”字符以上的任意字符串”的特殊符号，本例中代表“以ddd开头的所有字符串”。
 
 **(2)中间一致: 选取出**"abc**ddd" "ddd**abc""ab**ddd**c"
  
  所谓中间一致，就是选取出查询对象字符串中含有作为查询条件的字符串（这里是“ddd”）的记录的查询方法。无论该字符串出现在对象字符串的最后还是中间都没有关系。
  
  代码如下：
 ```
  SELECT *
    FROM SampleLike
   WHERE strcol LIKE '%ddd%';
 ```
  结果如下：
  
  ![image](https://user-images.githubusercontent.com/59467331/118673281-76225c80-b82b-11eb-8138-a5dd1292bd53.png)

**(3)后方一致: 选取出**"abc**ddd"** 
  
  后方一致与前方一致相反，也就是选取出作为查询条件的字符串（这里是“ddd”）与查询对象字符串的末尾部分相同的记录的查询方法。
  
  代码如下：
 ```
  SELECT *
    FROM SampleLike
   WHERE strcol LIKE '%ddd';
 ```
  结果如下：

![image](https://user-images.githubusercontent.com/59467331/118673520-a7029180-b82b-11eb-891e-caa87522a839.png)

此外，我们还可以使用_（下划线）来代替%，但下划线代表了**任意一个字符**。

示例：选取出 strcol 列的值为“abc + 任意2个字符”的记录：

```
SELECT *
    FROM SampleLike
   WHERE strcol LIKE 'ddd__';
 ```
 结果如下：
 
 ![image](https://user-images.githubusercontent.com/59467331/118674045-12e4fa00-b82c-11eb-9b74-0364f9ffca31.png)
 
 

### 6.2.2 BEWTEEN谓词——范围查询

为方便下方的练习，我们在这里先创建本书1-2提到的product商品表：

```
-- 创建表：
CREATE TABLE Product
(product_id CHAR(4) NOT NULL,
product_name VARCHAR(100) NOT NULL,
product_type VARCHAR(32) NOT NULL,
sale_price INTEGER ,
purchase_price INTEGER ,
regist_date DATE ,
PRIMARY KEY (product_id));

-- 插入数据：
INSERT INTO Product VALUES ('0001', 'T恤' ,'衣服', 1000, 500, '2009-09-20');
INSERT INTO Product VALUES ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11');
INSERT INTO Product VALUES ('0003', '运动T恤', '衣服', 4000, 2800, NULL);
INSERT INTO Product VALUES ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');
INSERT INTO Product VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');
INSERT INTO Product VALUES ('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20');
INSERT INTO Product VALUES ('0007', '擦菜板', '厨房用具', 880, 790, '2008-04-28');
INSERT INTO Product VALUES ('0008', '圆珠笔', '办公用品', 100, NULL, '2009-11-11');
```
结果如下：

![image](https://user-images.githubusercontent.com/59467331/118675259-08773000-b82d-11eb-9ee1-aa567c52f96f.png)



  BETWEEN谓词可以进行范围查询，它使用了三个参数，例如，从product（商品）表中读取出销售单价（sale_price）为100日元到1000日元之间的商品时，可以使用如下代码：
```
SELECT product_name, sale_price
  From Product
 WHERE sale_price BETWEEN 100 AND 1000;
```

结果如下：

![image](https://user-images.githubusercontent.com/59467331/118675696-6277f580-b82d-11eb-81dd-a0621beb3bb0.png)

但注意，BETWEEN谓词的结果会包含100和1000这些临界值，若不想包含临界值，则应使用：

```
SELECT product_name, sale_price
  From Product
 WHERE sale_price > 100 
   AND sale_price < 1000;
```

### 6.2.3 IS NULL、IS NOT NULL——判断是否为NULL

为了选取出某些值为NULL的列的数据，不能使用 =，而只能使用特定的谓词IS NULL:
```
SELECT product_name, purchase_price
FROM Product
WHERE purchase_price IS NULL;
```
结果如下：

![image](https://user-images.githubusercontent.com/59467331/118676521-0f527280-b82e-11eb-9098-77440608da10.png)

与此相反，想要选取NULL以外的数据时，需要使用IS NOT NULL：
```
SELECT product_name, purchase_price
FROM Product
WHERE purchase_price IS NOT NULL;
```
结果如下：

![image](https://user-images.githubusercontent.com/59467331/118676734-3c068a00-b82e-11eb-9dfa-5948c110695e.png)

### 6.2.4 IN谓词——OR的简便用法

考虑如下例子：选取出进货单价（purchase_price）为320日元、500日元、5000日元的商品。这里使用之前学过的OR的SQL语句：

```
SELECT product_name, purchase_price
  From Product
 WHERE purchase_price = 320
    OR purchase_price = 500
	OR purchase_price = 5000;
```
结果如下：

![image](https://user-images.githubusercontent.com/59467331/118677200-a5869880-b82e-11eb-8e31-b8901675f579.png)

虽然上述方法也能实现这一目的，但随着选取对象的增多，SQL语句也会越来越长，这时，IN谓词可以替换上述SQL语句：
```
SELECT product_name, purchase_price
  From Product
 WHERE purchase_price IN (320, 500, 5000);
```
结果如下:

![image](https://user-images.githubusercontent.com/59467331/118677597-ebdbf780-b82e-11eb-810c-6b5ac0eef02f.png)


若使用NOT IN，则可选取进货价不为这些价格的商品，在此不再赘述。

#### 6.2.4.1 使用子查询作为IN谓词的参数

   IN谓词具有其他谓词没有的用法，即可以使用子查询作为其参数，子查询是SQL内部生成的表/图，因为也可以说“能够将表/图作为IN的参数”。
   
   为方便练习，我们再创立一个商店商品表，之前的商品表告诉我们全部的商品库存清单，但现实中这些商品只能在个别商店销售。ShopProduct商店商品表显示出哪些商店销售哪些商品。

```
--创建商店商品表：

CREATE TABLE ShopProduct
(shop_id CHAR(4) NOT NULL,
shop_name VARCHAR(200) NOT NULL,
product_id CHAR(4) NOT NULL,
quantity INTEGER NOT NULL,
PRIMARY KEY (shop_id, product_id));

--插入数据：

BEGIN TRANSACTION;
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000A', '东京', '0001', 30);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000A', '东京', '0002', 50);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000A', '东京', '0003', 15);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0002', 30);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0003', 120);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0004', 20);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0006', 10);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0007', 40);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0003', 20);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0004', 50);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0006', 90);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0007', 70);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000D', '福冈', '0001', 100);
COMMIT;
```

结果如下：

![image](https://user-images.githubusercontent.com/59467331/118679150-390c9900-b830-11eb-8d1c-ed82a2981c00.png)


    做好准备工作以后，考虑如下案例：读取“大阪店（000C）在售的商品（product_id）的销售单价（sale_price）”。其中商店和在售商品均属于ShopProduct商店商品表，而在售商品和销售单价均属于Product商品表，因此在售商品（product_id）是两个表的桥梁。首先在商店商品表中查询大阪店的在售商品，以此为IN谓词的子查询，将IN谓词应用于查询Product商品表便完成了上述目的。

```
SELECT product_name, sale_price
FROM Product
WHERE product_id IN (SELECT product_id
					   FROM ShopProduct
					  WHERE shop_id = '000C');
```
结果如下:

![image](https://user-images.githubusercontent.com/59467331/118680664-82a9b380-b831-11eb-8fd2-f3c824aac7b1.png)

  为什么一定要使用子查询呢？这是因为 ShopProduct（商店商品）表并不是一成不变的。实际上由于各个商店销售的商品都在不断发生变化，因此 ShopProduct 表内大阪店销售的商品也会发生变化。如果 SELECT 语句中没有使用子查询的话，一旦商品发生了改变，那么 SELECT 语句也不得不进行修改，而且这样的修改工作会变得没完没了。反之，如果在 SELECT 语句中使用了子查询，那么即使数据发生了
变更，还可以继续使用同样的 SELECT 语句。这样也就减少了我们的常规作业（单纯的重复操作）。

   
**NOT IN和子查询**

   NOT IN 同样可以使用子查询作为参数，其语法也和IN 完全一样。考虑如下案例：选取出“在东京店（000A）以外销售的商品（product_id）的销售单价（sale_price）”：
 
```
SELECT product_name, sale_price
FROM Product
WHERE product_id NOT IN (SELECT product_id
					   FROM ShopProduct
					  WHERE shop_id = '000A');
```
结果如下：

![image](https://user-images.githubusercontent.com/59467331/118681203-fba90b00-b831-11eb-8d1d-c207776ac57e.png)


### 6.2.5 EXISTS谓词


 
 


